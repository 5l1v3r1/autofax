#!/bin/bash
still() {
	"$@" >/dev/null 2>&1
}

#kf kein Fehler
kf() {
	"$@" 2>/dev/null
}

# Installationsprogramm ermitteln
# inhaltlich parallel linst_cl::pruefipr( in kons.cpp
# Ubuntu:   libtiff-dev   libtiff5
# Opensuse: libtiff-devel libtiff5
# Fedora:   libtiff       libtiff-devel
# IdPR wird benötigt für: sudo
# IPR wird verwendet in: einricht, dieses für: make, ctags, gtags, vim (in viall)
# IP_R wird verwendet für: Makefile
getIPR() {
  CTAGS=ctags;
	sus=0;
	deb=0;
	fed=0;
	{ still which zypper &&{ 
	  sus=1;
		Z=zypper;g=--gpg-auto-import-keys;IdPR="$Z -n $g in -f ";IP_R="sudo $Z $g in ";UPR="sudo $Z rm -u ";pgroff=groff;
		# die nächsten beiden Variablen dürften 26.3.17 unnötig werden
  REPOS="sudo $Z lr|grep 'g++\|devel_gcc'\>$KR||sudo $Z ar http://download.opensuse.org/repositories/devel:/gcc/\`cat /etc/*-release|grep ^NAME= |cut -d'\"' -f2|sed 's/ /_/'\`_\`cat /etc/*-release|grep ^VERSION_ID= |cut -d'\"' -f2\`/devel:gcc.repo;";
  urepo="sudo $Z lr|grep \\\\\"g++\\\\\|devel_gcc\\\\\"\>$KR && sudo $Z rr devel_gcc;";
  COMP="gcc gcc-c++ \$(CCInst)";
	LT=${_LT}-${dev};
	} }||
	{ still which apt-get &&{ deb=1;IdPR="apt-get --assume-yes install --reinstall ";IP_R="sudo $IdPR";
	                                    UPR="sudo apt-get -f install; sudo apt-get --auto-remove purge ";
																			dev=dev;
																			COMP="build-essential linux-headers-\$(shell uname -r)";
																			LT=${_LT}-${dev};
																			CTAGS=exuberant-ctags;} }||
	{ still which dnf &&{ fed=1;IdPR="dnf -y install ";UPR="sudo dnf remove ";} }||
	{ still which yum &&{ fed=1;IdPR="yum -y install ";UPR="sudo yum remove ";} }
	[ $fed = 1 ] &&{ libmc=mysql;libmc1=mariadb;COMP="make automake gcc-c++ kernel-devel";IP_R="sudo $IdPR";LT="${_LT} ${_LT}-${dev}";LT5="";}
	{ still which rpm &&{ SPR="rpm -q ";UDPR="sudo rpm -e --nodeps ";};}||
	{ still which dpkg &&{ SPR="dpkg -s ";UDPR="sudo apt-get -f install; sudo dpkg -r --force-depends ";};}
	IPR="sudo $IdPR";
	DATEIEN="`find . -maxdepth 1 -name ${PWD##*/}.cpp -printf '%f '``find . -maxdepth 1 -name ${PWD##*/}.h -printf '%f '``find . -maxdepth 1 \( -name '*.cpp' -or -name '*.h' \) -not -path "*${PWD##*/}*" -printf '%f '|sort`man_?? Makefile configure install.sh viall .exrc $UNF $INSTLOG"
}

exportvars() {
	rm -f vars;
	for v in KR KF IPR IP_R UPR UDPR SPR UNROH UNF AUNF INSTLOG pgroff LT LT5 LM18 dev libmc libmc1 REPOS urepo COMP DATEIEN; do
	  eval nv=\$$v; 
		printf "$v:=$nv\n">>vars; 
	done;
}

ausricht() {
# im der letzten eingerückten Block der Bildschirmausgabe stehen die tatsächlich installierten Programme
# siehe int linst_cl::doinst(kons.cpp)
  cat "$1" >> $GINSTLOG
	if [ $sus = 1 ]; then
# am Schluss hole hold-Register, entferne Zeilenumbrueche, fasse Leerzeichen zusammen; wenn nicht zwischen NEW package und leerer Zeile, loesche Zeile;
# loesche auch die letzten Suchmusterzeilen (NEW package und leere Zeile); haenge ans Hold-Register an;
   sed -ni.bak '${g;s/\n//g;s/\s\+/ /g;p};/NEW package\|reinstalled:/,/^$/!d;//d;H' "$1";
	elif [ $fed = 1 ]; then
# Beispiel für dnf:	 
#	 V=Verifying;sed -n '/'$V'/{s/[ ]*'$V'[ ]*:[ ]*\([^ ]*\).*/\1/;H};${x;s/\n/ /g;p}' /DATA/down/inst_vim_orig
# in Fedora: nach dem Programm kommt mit einem Leerzeichen eine Versionsnr., die unnötig ist für die Deninstallation
#		sed -ni.bak '/^\s/{s/\([^ ]\+\)[ ][^ ]\+/ \1/g;s/\s\+/ /g;h;:a;n;/^\s/{s/\([^ ]\+\)[ ][^ ]\+/ \1/g;s/\s\+/ /g;H;ba};};${x;s/\n/ /g;p}' "$1";
# ausserdem: nicht der letzte eingerueckte Block, sondern der hinter "Installed:" (vielleicht auch "Installiert:")
# am Schluss hole hold-Register, entferne Zeilenumbrueche, fasse Leerzeichen zusammen; wenn nicht zwischen Install und leerer Zeile, loesche Zeile;
# loesche auch die letzten Suchmusterzeilen (Install und leere Zeile); uebertrage nur den ersten von zwei Textbloecken; haenge ans Hold-Register an;
   sed -ni.bak '${g;s/\n//g;s/\s\+/ /g;p};/Install[^: dt]*[dt]:/,/^$/!d;//d;{s/\([^ ]\+\)[ ][^ ]\+/\1/g};H' "$1";
	else # apt
# am Schluss hole hold-Register, entferne Zeilenumbrueche, fasse Leerzeichen zusammen; wenn nicht zwischen NEW package und vor anfangende Zeile, 
# loesche Zeile; loesche auch die letzten Suchmusterzeilen (NEW package und leere Zeile); haenge ans Hold-Register an;
	  sed -ni.bak '${g;s/\n//g;s/\s\+/ /g;p};/NEW package\|NEUEN Pakete/,/^[^ ]/!d;//d;H' "$1";
	fi;
	sed -i.baksed 's/ libstdc[^g ]*gcc[^ ]*/ /g;s/ libgcc[^ ]*/ /g;s/ libselinux[^ ]*/ /g' "$1"; 
	# die Deinstallation von libgcc.x86_64 wirkte sich irgendwie ungünstig auf das System aus ...
	# noch ungünstiger die von libselinux ...
# s. doanfg(string& datei, string& inhalt, string& comment) in kons.cpp
	IP=$(cat $1)
	printf "IP: '$IP'\n">>$GINSTLOG
#	 for IP in $(cat $1); do
# wenn $AUNF fehlt oder eine der in $1 erwähnten Programm dort nicht aufgeführt ist, dann zuinstallieren=ja; "; vi ..." nicht zu werten
     [ ! -f $AUNF ]&&zuinst=ja||{
      for E in $IP; do
       grep -q "[^;] $E" $AUNF||{ zuinst=ja;break;}
      done;				
     }
     [ -n "$zuinst" ]&&{
			T=${UDPR}$IP;
			printf "$T\n# $3\nprintf \"(Inst: $(date +%F\ %T)): \$blau%%s\$reset\\\n\" \"$T\"\n">>$AUNF;
			[ $2/ = "vim/" ] &&{ printf "alias vi>$KR&&sudo unalias vi\necho \"alias vi>$KR&&sudo unalias vi\"\n">>$AUNF;}
		 }
#	 done;
#	 test -f $AUNF&&grep -q " $2" $AUNF||{
#	  T=${UPR}$2;
#		printf "$T\nprintf \"\$blau%%s\$reset\\\n\" \"$T\"\n">>$AUNF;
#	 }
}
# wird aufgerufen im Hauptprogramm configure, wenn 1. Parameter 'inst', dieses in Makefile mit: $(COMP), $$lc, $(pgd), $(slc), $(LT), $(LT5), $(pgroff)
# sonst mit 'make', aus viall mit 'ctags', 'global' und 'vim'
einricht() {
# wenn $1 nicht aufrufbar oder "_", dann installiere $2
 if [ $1 != _ ]&& still which $1; then
   if [ $3/ = verbose/ ]; then  \
	 printf "$blau$1$reset installed/ schon da, $blau$2$reset not to be installed/ übersprungen\n"; fi
 else
   getIPR;
	 [ $1 = _ ]|| printf "$blau$1$reset not found/ nicht gefunden => "  
	 printf "Installing/ Installiere $blau$2$reset ...\n";
	 [ $1 = "vim" -a $fed = 1 ] &&{ sudo yum update vim-minimal;}
	 rweg=0;
   CMD=${IPR};
	 [ $1 = "g++" -a -n "$Z" ] &&{
		 CMD=${IP_R};
		 sudo $Z lr|grep 'g++\|devel_gcc'>/dev/null 2>&1 ||{ 
			 GREPO=http://download.opensuse.org/repositories/devel:/gcc/
			 GREPO=${GREPO}`cat /etc/*-release|grep ^NAME= |cut -d\" -f2|sed 's/ /_/'`_
			 GREPO=${GREPO}`cat /etc/*-release|grep ^VERSION_ID= |cut -d\" -f2`
			 GREPO=${GREPO}/devel:gcc.repo;
			 printf "Adding Repository/ Füge Repository hinzu: $blau$GREPO$reset\n";
			 sudo $Z rr devel_gcc >/dev/null 2>&1;
			 sudo $Z ar $GREPO && rweg=1;
		 }
	 }
	 LOG=inst_${2// /_}.log; # Leerzeichen entfernen
	 echo ${CMD}$2
	 ${CMD}$2|tee $LOG # "$2" geht bei mehreren Wörtern nicht, z.B. "groff-base groff"
	 printf "\nRueckmeldung bei einricht $2:\n">>$GINSTLOG
	 ausricht "$LOG" $1 "${IPR}$2"
	 if [ $1 = "g++" -a -n "$Z" -a $rweg = 1 ]; then
	 	 printf "Removing Repository/ Entferne Repository ${blau}devel_gcc$reset again/ wieder\n"
		 sudo $Z rr devel_gcc;
	 else true; fi
 fi
}

UNROH=uninstall
UNF=${UNROH}inv # Name muss identisch sein mit Ende von uindt in kons.cpp 
DN=/dev/null
KR="$DN 2>&1" # keine Rueckmeldung
KF=" 2>$DN" # keine Fehlermeldung
pgroff="groff-base groff"
dev=devel
libmc=libmysqlclient
libmc1=libmariadbclient
fed=0
Z=""
CCInst=gcc6-c++

ICH=$(basename $0)
if [ $ICH = -bash ]; then 
 declare -r ICHges=$(readlink -f ${BASH_SOURCE[0]})
 ICH=$(basename $ICHges)
fi

PROG=autofax
INSTLOG=inst.log
GINSTLOG=$HOME/$PROG/$INSTLOG
mkdir -p $HOME/$PROG
AUNF=$HOME/$PROG/$UNF
_LT="libtiff"
LT5="${_LT}5"
LM18=libmysqlclient18

getIPR;
# diese Datei wird wegen obigem in viall gesourct, deshalb dort der Rest zu uebergehen
if test "$ICH" = configure -o "$ICH" = install.sh -o "$ICH" = autofax_inst.sh; then
rot="\033[1;31m"
gruen="\033[1;32m"
blau="\033[1;34m"
reset="\033[0m"
if test "$1" = inst; then
# um aus Makefile hier etwas installieren zu koennen
  einricht "$2" "$3" "$4"
  exit
fi

echo \"$SITZV\">sitzdt
# Gruppen, deren Mitglieder sudo aufrufen koennen; fuer Debian muss zuerst 'sudo' genannt werden, weil eine Zuordnung zu 'root' nichts hilft (s.u. tail)
SUG="admin\|root\|sudo\|wheel\|ntadmin";

# hier geht's los
# falls der Benutzer 'sudo' fehlt oder der aktuelle Benutzer ihn nicht aufrufen darf, weil er nicht Mitglied einer Administratorgruppe ist ...
INSTP=sudo;still which $INSTP||{
	printf "Must install '$INSTP'. "
	printf "Please enter ${blau}root$reset's password at the next question:\n"
	printf "Muss '$INSTP' einrichten. "
	printf "Bitte geben Sie bei der Frage das Passwort von '${blau}root$reset' ein:\n";
#	test -f $AUNF&&grep -q "[^;] sudo" $AUNF||printf "${UPR}sudo\nprintf \"\$blau%%s\$reset\\\n\" \"${UPR}sudo\"\n">>$AUNF;
#	su -c "$IdPR sudo;";
	 LOG=inst_$INSTP.log;
	 su -c "$IdPR $INSTP"|tee "$LOG";
	 printf "\nRueckmeldung su -c \"$IdPR $INSTP\":\n">>$GINSTLOG
	 ausricht "$LOG";
}
# 0=sudo aufrufbar
a=$(sudo -n -v 2>&1);test -z "$a" || echo $a|grep -q "assw" ||{
	printf "Must allow '$blau$USER$reset' to call '${blau}sudo$reset'."
	printf "Please enter ${blau}root$reset's password at the next question:\n"
	printf "Then please log out and in again, change to the directory '$blau$PWD$reset' and then call '${blau}sh install.sh$reset'!\n"
	printf "Muss '$blau$USER$reset' den Aufruf von '${blau}sudo$reset' ermoeglichen. "
	printf "Bitte geben Sie bei der Frage das Passwort von '${blau}root$reset' ein:\n";
	printf "Danach loggen Sie sich bitte aus und nochmal ein, wechseln Sie nach '$blau$PWD$reset' und rufen Sie '${blau}sh install.sh$reset' auf!\n";
	su -c "usermod -aG $(cut -d: -f1 /etc/group|grep -w "$SUG"|tail -n1) "$USER";" && exit
}
# which sudo >/dev/null && id -Gzn $USER|grep -qw "$SUG";}||{ 
# falls make fehlt, dann installieren ...
einricht make make
# $SPR make >$DN 2>&1 ||{ echo Installing/ Installiere 'make' ....; id su >$DN 2>&1 && { su -c "$IPR make;";true;} || sudo $IPR make; grep -q make $AUNF||printf "${UPR}make\necho \"${UPR}make\"\n">>$AUNF; }
exportvars;
Mf=Makefile;Mfr=$Mf.roh; test -f $Mfr && mv $Mfr $Mf
fi
